# 876. Средний элемент связанного списка

Это задача с LeetCode ([ссылка](https://leetcode.com/problems/middle-of-the-linked-list/description/)).

## Описание задачи

Дано начало `head` односвязного списка, верните `средний узел этого списка`.

Если существует два средних узла, верните второй средний узел.

## Примеры

### Пример 1:

![Example 1](pics\lc-midlist1.jpg)

**Вход:** `head = [1,2,3,4,5]`  
**Выход:** `[3,4,5]`  
**Объяснение:** Средний узел списка - это узел 3.

### Пример 2:

![Example 2](pics\lc-midlist2.jpg)

**Вход:** `head = [1,2,3,4,5,6]`  
**Выход:** `[4,5,6]`  
**Объяснение:** Поскольку в списке два средних узла со значениями 3 и 4, мы возвращаем второй из них.

## Ограничения

- Количество узлов в списке находится в диапазоне `[1, 100]`.
- `1 <= Node.val <= 100`

## Решение

### Основной подход: Алгоритм Флойда (Медленный и быстрый указатели)

Для решения задачи используется алгоритм Флойда, также известный как техника "медленного и быстрого указателей". Это подвид паттерна "два указателя".

#### Как это работает:
1. Инициализируем два указателя `slow` и `fast` в начале списка (`head`)
2. Перемещаем `slow` на один шаг вперед, а `fast` на два шага вперед за одну итерацию
3. Продолжаем этот процесс, пока `fast` и `fast.next` не станут `None`
4. Когда `fast` достигает конца списка, `slow` будет указывать на середину списка

Этот подход эффективен, потому что когда быстрый указатель проходит весь список, медленный указатель проходит только половину пути.

### Альтернативный подход: Два прохода

Альтернативным решением было бы:
1. Сначала пройти по списку, чтобы подсчитать общее количество узлов (первый проход)
2. Затем пройти от начала списка до середины (второй проход)

Хотя этот подход также имеет временную сложность O(n), он требует двух проходов по списку, в то время как алгоритм Флойда требует только одного прохода.

### Анализ сложности

- **Временная сложность:** O(n), где n - количество узлов в списке. Нам нужно пройти по списку один раз.
- **Пространственная сложность:** O(1), так как мы используем только постоянное количество дополнительного пространства для двух указателей.

### Нюансы реализации

1. **Условие цикла:** Важно проверять `while fast and fast.next`, чтобы избежать ошибок доступа к атрибуту `next` у `None`.
2. **Обработка четного и нечетного количества элементов:** Алгоритм корректно обрабатывает оба случая:
   - При нечетном количестве элементов `slow` остановится на точной середине
   - При четном количестве элементов `slow` остановится на втором среднем элементе, что соответствует требованиям задачи